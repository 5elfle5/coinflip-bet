'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var walletStandardUtil = require('@solana/wallet-standard-util');

// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/
const SolanaMobileWalletAdapterErrorCode = {
    ERROR_ASSOCIATION_PORT_OUT_OF_RANGE: 'ERROR_ASSOCIATION_PORT_OUT_OF_RANGE',
    ERROR_REFLECTOR_ID_OUT_OF_RANGE: 'ERROR_REFLECTOR_ID_OUT_OF_RANGE',
    ERROR_FORBIDDEN_WALLET_BASE_URL: 'ERROR_FORBIDDEN_WALLET_BASE_URL',
    ERROR_SECURE_CONTEXT_REQUIRED: 'ERROR_SECURE_CONTEXT_REQUIRED',
    ERROR_SESSION_CLOSED: 'ERROR_SESSION_CLOSED',
    ERROR_SESSION_TIMEOUT: 'ERROR_SESSION_TIMEOUT',
    ERROR_WALLET_NOT_FOUND: 'ERROR_WALLET_NOT_FOUND',
    ERROR_INVALID_PROTOCOL_VERSION: 'ERROR_INVALID_PROTOCOL_VERSION',
};
class SolanaMobileWalletAdapterError extends Error {
    constructor(...args) {
        const [code, message, data] = args;
        super(message);
        this.code = code;
        this.data = data;
        this.name = 'SolanaMobileWalletAdapterError';
    }
}
// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/
const SolanaMobileWalletAdapterProtocolErrorCode = {
    // Keep these in sync with `mobilewalletadapter/common/ProtocolContract.java`.
    ERROR_AUTHORIZATION_FAILED: -1,
    ERROR_INVALID_PAYLOADS: -2,
    ERROR_NOT_SIGNED: -3,
    ERROR_NOT_SUBMITTED: -4,
    ERROR_TOO_MANY_PAYLOADS: -5,
    ERROR_ATTEST_ORIGIN_ANDROID: -100,
};
class SolanaMobileWalletAdapterProtocolError extends Error {
    constructor(...args) {
        const [jsonRpcMessageId, code, message, data] = args;
        super(message);
        this.code = code;
        this.data = data;
        this.jsonRpcMessageId = jsonRpcMessageId;
        this.name = 'SolanaMobileWalletAdapterProtocolError';
    }
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function createHelloReq(ecdhPublicKey, associationKeypairPrivateKey) {
    return __awaiter(this, void 0, void 0, function* () {
        const publicKeyBuffer = yield crypto.subtle.exportKey('raw', ecdhPublicKey);
        const signatureBuffer = yield crypto.subtle.sign({ hash: 'SHA-256', name: 'ECDSA' }, associationKeypairPrivateKey, publicKeyBuffer);
        const response = new Uint8Array(publicKeyBuffer.byteLength + signatureBuffer.byteLength);
        response.set(new Uint8Array(publicKeyBuffer), 0);
        response.set(new Uint8Array(signatureBuffer), publicKeyBuffer.byteLength);
        return response;
    });
}

function encode(input) {
    return window.btoa(input);
}

function createSIWSMessage(payload) {
    return walletStandardUtil.createSignInMessageText(payload);
}
function createSIWSMessageBase64(payload) {
    return encode(createSIWSMessage(payload));
}

// optional features
const SolanaSignTransactions = 'solana:signTransactions';
const SolanaCloneAuthorization = 'solana:cloneAuthorization';
const SolanaSignInWithSolana = 'solana:signInWithSolana';

/**
 * Creates a {@link MobileWallet} proxy that handles backwards compatibility and API to RPC conversion.
 *
 * @param protocolVersion the protocol version in use for this session/request
 * @param protocolRequestHandler callback function that handles sending the RPC request to the wallet endpoint.
 * @returns a {@link MobileWallet} proxy
 */
function createMobileWalletProxy(protocolVersion, protocolRequestHandler) {
    return new Proxy({}, {
        get(target, p) {
            if (target[p] == null) {
                target[p] = function (inputParams) {
                    return __awaiter(this, void 0, void 0, function* () {
                        const { method, params } = handleMobileWalletRequest(p, inputParams, protocolVersion);
                        const result = yield protocolRequestHandler(method, params);
                        // if the request tried to sign in but the wallet did not return a sign in result, fallback on message signing
                        if (method === 'authorize' && params.sign_in_payload && !result.sign_in_result) {
                            result['sign_in_result'] = yield signInFallback(params.sign_in_payload, result, protocolRequestHandler);
                        }
                        return handleMobileWalletResponse(p, result, protocolVersion);
                    });
                };
            }
            return target[p];
        },
        defineProperty() {
            return false;
        },
        deleteProperty() {
            return false;
        },
    });
}
/**
 * Handles all {@link MobileWallet} API requests and determines the correct MWA RPC method and params to call.
 * This handles backwards compatibility, based on the provided @protocolVersion.
 *
 * @param methodName the name of {@link MobileWallet} method that was called
 * @param methodParams the parameters that were passed to the method
 * @param protocolVersion the protocol version in use for this session/request
 * @returns the RPC request method and params that should be sent to the wallet endpoint
 */
function handleMobileWalletRequest(methodName, methodParams, protocolVersion) {
    let params = methodParams;
    let method = methodName
        .toString()
        .replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`)
        .toLowerCase();
    switch (methodName) {
        case 'authorize': {
            let { chain } = params;
            if (protocolVersion === 'legacy') {
                switch (chain) {
                    case 'solana:testnet': {
                        chain = 'testnet';
                        break;
                    }
                    case 'solana:devnet': {
                        chain = 'devnet';
                        break;
                    }
                    case 'solana:mainnet': {
                        chain = 'mainnet-beta';
                        break;
                    }
                    default: {
                        chain = params.cluster;
                    }
                }
                params.cluster = chain;
            }
            else {
                switch (chain) {
                    case 'testnet':
                    case 'devnet': {
                        chain = `solana:${chain}`;
                        break;
                    }
                    case 'mainnet-beta': {
                        chain = 'solana:mainnet';
                        break;
                    }
                }
                params.chain = chain;
            }
        }
        case 'reauthorize': {
            const { auth_token, identity } = params;
            if (auth_token) {
                switch (protocolVersion) {
                    case 'legacy': {
                        method = 'reauthorize';
                        params = { auth_token: auth_token, identity: identity };
                        break;
                    }
                    default: {
                        method = 'authorize';
                        break;
                    }
                }
            }
            break;
        }
    }
    return { method, params };
}
/**
 * Handles all {@link MobileWallet} API responses and modifies the response for backwards compatibility, if needed
 *
 * @param method the {@link MobileWallet} method that was called
 * @param response the original response that was returned by the method call
 * @param protocolVersion the protocol version in use for this session/request
 * @returns the possibly modified response
 */
function handleMobileWalletResponse(method, response, protocolVersion) {
    switch (method) {
        case 'getCapabilities': {
            const capabilities = response;
            switch (protocolVersion) {
                case 'legacy': {
                    const features = [SolanaSignTransactions];
                    if (capabilities.supports_clone_authorization === true) {
                        features.push(SolanaCloneAuthorization);
                    }
                    return Object.assign(Object.assign({}, capabilities), { features: features });
                }
                case 'v1': {
                    return Object.assign(Object.assign({}, capabilities), { supports_sign_and_send_transactions: true, supports_clone_authorization: capabilities.features.includes(SolanaCloneAuthorization) });
                }
            }
        }
    }
    return response;
}
function signInFallback(signInPayload, authorizationResult, protocolRequestHandler) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const domain = (_a = signInPayload.domain) !== null && _a !== void 0 ? _a : window.location.host;
        const address = authorizationResult.accounts[0].address;
        const siwsMessage = createSIWSMessageBase64(Object.assign(Object.assign({}, signInPayload), { domain, address }));
        const signMessageResult = yield protocolRequestHandler('sign_messages', {
            addresses: [address],
            payloads: [siwsMessage]
        });
        const signInResult = {
            address: address,
            signed_message: siwsMessage,
            signature: signMessageResult.signed_payloads[0].slice(siwsMessage.length)
        };
        return signInResult;
    });
}

const SEQUENCE_NUMBER_BYTES = 4;
function createSequenceNumberVector(sequenceNumber) {
    if (sequenceNumber >= 4294967296) {
        throw new Error('Outbound sequence number overflow. The maximum sequence number is 32-bytes.');
    }
    const byteArray = new ArrayBuffer(SEQUENCE_NUMBER_BYTES);
    const view = new DataView(byteArray);
    view.setUint32(0, sequenceNumber, /* littleEndian */ false);
    return new Uint8Array(byteArray);
}

const INITIALIZATION_VECTOR_BYTES = 12;
const ENCODED_PUBLIC_KEY_LENGTH_BYTES = 65;
function encryptMessage(plaintext, sequenceNumber, sharedSecret) {
    return __awaiter(this, void 0, void 0, function* () {
        const sequenceNumberVector = createSequenceNumberVector(sequenceNumber);
        const initializationVector = new Uint8Array(INITIALIZATION_VECTOR_BYTES);
        crypto.getRandomValues(initializationVector);
        const ciphertext = yield crypto.subtle.encrypt(getAlgorithmParams(sequenceNumberVector, initializationVector), sharedSecret, new TextEncoder().encode(plaintext));
        const response = new Uint8Array(sequenceNumberVector.byteLength + initializationVector.byteLength + ciphertext.byteLength);
        response.set(new Uint8Array(sequenceNumberVector), 0);
        response.set(new Uint8Array(initializationVector), sequenceNumberVector.byteLength);
        response.set(new Uint8Array(ciphertext), sequenceNumberVector.byteLength + initializationVector.byteLength);
        return response;
    });
}
function decryptMessage(message, sharedSecret) {
    return __awaiter(this, void 0, void 0, function* () {
        const sequenceNumberVector = message.slice(0, SEQUENCE_NUMBER_BYTES);
        const initializationVector = message.slice(SEQUENCE_NUMBER_BYTES, SEQUENCE_NUMBER_BYTES + INITIALIZATION_VECTOR_BYTES);
        const ciphertext = message.slice(SEQUENCE_NUMBER_BYTES + INITIALIZATION_VECTOR_BYTES);
        const plaintextBuffer = yield crypto.subtle.decrypt(getAlgorithmParams(sequenceNumberVector, initializationVector), sharedSecret, ciphertext);
        const plaintext = getUtf8Decoder().decode(plaintextBuffer);
        return plaintext;
    });
}
function getAlgorithmParams(sequenceNumber, initializationVector) {
    return {
        additionalData: sequenceNumber,
        iv: initializationVector,
        name: 'AES-GCM',
        tagLength: 128, // 16 byte tag => 128 bits
    };
}
let _utf8Decoder;
function getUtf8Decoder() {
    if (_utf8Decoder === undefined) {
        _utf8Decoder = new TextDecoder('utf-8');
    }
    return _utf8Decoder;
}

function generateAssociationKeypair() {
    return __awaiter(this, void 0, void 0, function* () {
        return yield crypto.subtle.generateKey({
            name: 'ECDSA',
            namedCurve: 'P-256',
        }, false /* extractable */, ['sign'] /* keyUsages */);
    });
}

function generateECDHKeypair() {
    return __awaiter(this, void 0, void 0, function* () {
        return yield crypto.subtle.generateKey({
            name: 'ECDH',
            namedCurve: 'P-256',
        }, false /* extractable */, ['deriveKey', 'deriveBits'] /* keyUsages */);
    });
}

function encryptJsonRpcMessage(jsonRpcMessage, sharedSecret) {
    return __awaiter(this, void 0, void 0, function* () {
        const plaintext = JSON.stringify(jsonRpcMessage);
        const sequenceNumber = jsonRpcMessage.id;
        return encryptMessage(plaintext, sequenceNumber, sharedSecret);
    });
}
function decryptJsonRpcMessage(message, sharedSecret) {
    return __awaiter(this, void 0, void 0, function* () {
        const plaintext = yield decryptMessage(message, sharedSecret);
        const jsonRpcMessage = JSON.parse(plaintext);
        if (Object.hasOwnProperty.call(jsonRpcMessage, 'error')) {
            throw new SolanaMobileWalletAdapterProtocolError(jsonRpcMessage.id, jsonRpcMessage.error.code, jsonRpcMessage.error.message);
        }
        return jsonRpcMessage;
    });
}

function parseHelloRsp(payloadBuffer, // The X9.62-encoded wallet endpoint ephemeral ECDH public keypoint.
associationPublicKey, ecdhPrivateKey) {
    return __awaiter(this, void 0, void 0, function* () {
        const [associationPublicKeyBuffer, walletPublicKey] = yield Promise.all([
            crypto.subtle.exportKey('raw', associationPublicKey),
            crypto.subtle.importKey('raw', payloadBuffer.slice(0, ENCODED_PUBLIC_KEY_LENGTH_BYTES), { name: 'ECDH', namedCurve: 'P-256' }, false /* extractable */, [] /* keyUsages */),
        ]);
        const sharedSecret = yield crypto.subtle.deriveBits({ name: 'ECDH', public: walletPublicKey }, ecdhPrivateKey, 256);
        const ecdhSecretKey = yield crypto.subtle.importKey('raw', sharedSecret, 'HKDF', false /* extractable */, ['deriveKey'] /* keyUsages */);
        const aesKeyMaterialVal = yield crypto.subtle.deriveKey({
            name: 'HKDF',
            hash: 'SHA-256',
            salt: new Uint8Array(associationPublicKeyBuffer),
            info: new Uint8Array(),
        }, ecdhSecretKey, { name: 'AES-GCM', length: 128 }, false /* extractable */, ['encrypt', 'decrypt']);
        return aesKeyMaterialVal;
    });
}

function parseSessionProps(message, sharedSecret) {
    return __awaiter(this, void 0, void 0, function* () {
        const plaintext = yield decryptMessage(message, sharedSecret);
        const jsonProperties = JSON.parse(plaintext);
        let protocolVersion = 'legacy';
        if (Object.hasOwnProperty.call(jsonProperties, 'v')) {
            switch (jsonProperties.v) {
                case 1:
                case '1':
                case 'v1':
                    protocolVersion = 'v1';
                    break;
                case 'legacy':
                    protocolVersion = 'legacy';
                    break;
                default:
                    throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_INVALID_PROTOCOL_VERSION, `Unknown/unsupported protocol version: ${jsonProperties.v}`);
            }
        }
        return ({
            protocol_version: protocolVersion
        });
    });
}

function getRandomAssociationPort() {
    return assertAssociationPort(49152 + Math.floor(Math.random() * (65535 - 49152 + 1)));
}
function assertAssociationPort(port) {
    if (port < 49152 || port > 65535) {
        throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_ASSOCIATION_PORT_OUT_OF_RANGE, `Association port number must be between 49152 and 65535. ${port} given.`, { port });
    }
    return port;
}

// https://stackoverflow.com/a/9458996/802047
function arrayBufferToBase64String(buffer) {
    let binary = '';
    const bytes = new Uint8Array(buffer);
    const len = bytes.byteLength;
    for (let ii = 0; ii < len; ii++) {
        binary += String.fromCharCode(bytes[ii]);
    }
    return window.btoa(binary);
}

function getStringWithURLUnsafeCharactersReplaced(unsafeBase64EncodedString) {
    return unsafeBase64EncodedString.replace(/[/+=]/g, (m) => ({
        '/': '_',
        '+': '-',
        '=': '.',
    }[m]));
}

function getRandomReflectorId() {
    return assertReflectorId(getRandomInt(0, 9007199254740991)); // 0 < id < 2^53 - 1
}
function getRandomInt(min, max) {
    const randomBuffer = new Uint32Array(1);
    window.crypto.getRandomValues(randomBuffer);
    let randomNumber = randomBuffer[0] / (0xffffffff + 1);
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(randomNumber * (max - min + 1)) + min;
}
function assertReflectorId(id) {
    if (id < 0 || id > 9007199254740991) { // 0 < id < 2^53 - 1
        throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_REFLECTOR_ID_OUT_OF_RANGE, `Association port number must be between 49152 and 65535. ${id} given.`, { id });
    }
    return id;
}

const INTENT_NAME = 'solana-wallet';
function getPathParts(pathString) {
    return (pathString
        // Strip leading and trailing slashes
        .replace(/(^\/+|\/+$)/g, '')
        // Return an array of directories
        .split('/'));
}
function getIntentURL(methodPathname, intentUrlBase) {
    let baseUrl = null;
    if (intentUrlBase) {
        try {
            baseUrl = new URL(intentUrlBase);
        }
        catch (_a) { } // eslint-disable-line no-empty
        if ((baseUrl === null || baseUrl === void 0 ? void 0 : baseUrl.protocol) !== 'https:') {
            throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_FORBIDDEN_WALLET_BASE_URL, 'Base URLs supplied by wallets must be valid `https` URLs');
        }
    }
    baseUrl || (baseUrl = new URL(`${INTENT_NAME}:/`));
    const pathname = methodPathname.startsWith('/')
        ? // Method is an absolute path. Replace it wholesale.
            methodPathname
        : // Method is a relative path. Merge it with the existing one.
            [...getPathParts(baseUrl.pathname), ...getPathParts(methodPathname)].join('/');
    return new URL(pathname, baseUrl);
}
function getAssociateAndroidIntentURL(associationPublicKey, putativePort, associationURLBase, protocolVersions = ['v1']) {
    return __awaiter(this, void 0, void 0, function* () {
        const associationPort = assertAssociationPort(putativePort);
        const exportedKey = yield crypto.subtle.exportKey('raw', associationPublicKey);
        const encodedKey = arrayBufferToBase64String(exportedKey);
        const url = getIntentURL('v1/associate/local', associationURLBase);
        url.searchParams.set('association', getStringWithURLUnsafeCharactersReplaced(encodedKey));
        url.searchParams.set('port', `${associationPort}`);
        protocolVersions.forEach((version) => {
            url.searchParams.set('v', version);
        });
        return url;
    });
}
function getRemoteAssociateAndroidIntentURL(associationPublicKey, hostAuthority, putativeId, associationURLBase, protocolVersions = ['v1']) {
    return __awaiter(this, void 0, void 0, function* () {
        const reflectorId = assertReflectorId(putativeId);
        const exportedKey = yield crypto.subtle.exportKey('raw', associationPublicKey);
        const encodedKey = arrayBufferToBase64String(exportedKey);
        const url = getIntentURL('v1/associate/remote', associationURLBase);
        url.searchParams.set('association', getStringWithURLUnsafeCharactersReplaced(encodedKey));
        url.searchParams.set('reflector', `${hostAuthority}`);
        url.searchParams.set('id', `${reflectorId}`);
        protocolVersions.forEach((version) => {
            url.searchParams.set('v', version);
        });
        return url;
    });
}

// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/
const Browser = {
    Firefox: 0,
    Other: 1,
};
function assertUnreachable(x) {
    return x;
}
function getBrowser() {
    return navigator.userAgent.indexOf('Firefox/') !== -1 ? Browser.Firefox : Browser.Other;
}
function getDetectionPromise() {
    // Chrome and others silently fail if a custom protocol is not supported.
    // For these, we wait to see if the browser is navigated away from in
    // a reasonable amount of time (ie. the native wallet opened).
    return new Promise((resolve, reject) => {
        function cleanup() {
            clearTimeout(timeoutId);
            window.removeEventListener('blur', handleBlur);
        }
        function handleBlur() {
            cleanup();
            resolve();
        }
        window.addEventListener('blur', handleBlur);
        const timeoutId = setTimeout(() => {
            cleanup();
            reject();
        }, 2000);
    });
}
let _frame = null;
function launchUrlThroughHiddenFrame(url) {
    if (_frame == null) {
        _frame = document.createElement('iframe');
        _frame.style.display = 'none';
        document.body.appendChild(_frame);
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    _frame.contentWindow.location.href = url.toString();
}
function launchAssociation(associationUrl) {
    return __awaiter(this, void 0, void 0, function* () {
        if (associationUrl.protocol === 'https:') {
            // The association URL is an Android 'App Link' or iOS 'Universal Link'.
            // These are regular web URLs that are designed to launch an app if it
            // is installed or load the actual target webpage if not.
            window.location.assign(associationUrl);
        }
        else {
            // The association URL has a custom protocol (eg. `solana-wallet:`)
            try {
                const browser = getBrowser();
                switch (browser) {
                    case Browser.Firefox:
                        // If a custom protocol is not supported in Firefox, it throws.
                        launchUrlThroughHiddenFrame(associationUrl);
                        // If we reached this line, it's supported.
                        break;
                    case Browser.Other: {
                        const detectionPromise = getDetectionPromise();
                        window.location.assign(associationUrl);
                        yield detectionPromise;
                        break;
                    }
                    default:
                        assertUnreachable(browser);
                }
            }
            catch (e) {
                throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_WALLET_NOT_FOUND, 'Found no installed wallet that supports the mobile wallet protocol.');
            }
        }
    });
}
function startSession(associationPublicKey, associationURLBase) {
    return __awaiter(this, void 0, void 0, function* () {
        const randomAssociationPort = getRandomAssociationPort();
        const associationUrl = yield getAssociateAndroidIntentURL(associationPublicKey, randomAssociationPort, associationURLBase);
        yield launchAssociation(associationUrl);
        return randomAssociationPort;
    });
}
function getRemoteSessionUrl(associationPublicKey, hostAuthority, associationURLBase) {
    return __awaiter(this, void 0, void 0, function* () {
        const randomReflectorId = getRandomReflectorId();
        const associationUrl = yield getRemoteAssociateAndroidIntentURL(associationPublicKey, hostAuthority, randomReflectorId, associationURLBase);
        return { associationUrl, reflectorId: randomReflectorId };
    });
}

const WEBSOCKET_CONNECTION_CONFIG = {
    /**
     * 300 milliseconds is a generally accepted threshold for what someone
     * would consider an acceptable response time for a user interface
     * after having performed a low-attention tapping task. We set the initial
     * interval at which we wait for the wallet to set up the websocket at
     * half this, as per the Nyquist frequency, with a progressive backoff
     * sequence from there. The total wait time is 30s, which allows for the
     * user to be presented with a disambiguation dialog, select a wallet, and
     * for the wallet app to subsequently start.
     */
    retryDelayScheduleMs: [150, 150, 200, 500, 500, 750, 750, 1000],
    timeoutMs: 30000,
};
const WEBSOCKET_PROTOCOL = 'com.solana.mobilewalletadapter.v1';
function assertSecureContext() {
    if (typeof window === 'undefined' || window.isSecureContext !== true) {
        throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SECURE_CONTEXT_REQUIRED, 'The mobile wallet adapter protocol must be used in a secure context (`https`).');
    }
}
function assertSecureEndpointSpecificURI(walletUriBase) {
    let url;
    try {
        url = new URL(walletUriBase);
    }
    catch (_a) {
        throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_FORBIDDEN_WALLET_BASE_URL, 'Invalid base URL supplied by wallet');
    }
    if (url.protocol !== 'https:') {
        throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_FORBIDDEN_WALLET_BASE_URL, 'Base URLs supplied by wallets must be valid `https` URLs');
    }
}
function getSequenceNumberFromByteArray(byteArray) {
    const view = new DataView(byteArray);
    return view.getUint32(0, /* littleEndian */ false);
}
function transact(callback, config) {
    return __awaiter(this, void 0, void 0, function* () {
        assertSecureContext();
        const associationKeypair = yield generateAssociationKeypair();
        const sessionPort = yield startSession(associationKeypair.publicKey, config === null || config === void 0 ? void 0 : config.baseUri);
        const websocketURL = `ws://localhost:${sessionPort}/solana-wallet`;
        let connectionStartTime;
        const getNextRetryDelayMs = (() => {
            const schedule = [...WEBSOCKET_CONNECTION_CONFIG.retryDelayScheduleMs];
            return () => (schedule.length > 1 ? schedule.shift() : schedule[0]);
        })();
        let nextJsonRpcMessageId = 1;
        let lastKnownInboundSequenceNumber = 0;
        let state = { __type: 'disconnected' };
        return new Promise((resolve, reject) => {
            let socket;
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const jsonRpcResponsePromises = {};
            const handleOpen = () => __awaiter(this, void 0, void 0, function* () {
                if (state.__type !== 'connecting') {
                    console.warn('Expected adapter state to be `connecting` at the moment the websocket opens. ' +
                        `Got \`${state.__type}\`.`);
                    return;
                }
                socket.removeEventListener('open', handleOpen);
                // previous versions of this library and walletlib incorrectly implemented the MWA session 
                // establishment protocol for local connections. The dapp is supposed to wait for the 
                // APP_PING message before sending the HELLO_REQ. Instead, the dapp was sending the HELLO_REQ 
                // immediately upon connection to the websocket server regardless of wether or not an 
                // APP_PING was sent by the wallet/websocket server. We must continue to support this behavior 
                // in case the user is using a wallet that has not updated their walletlib implementation. 
                const { associationKeypair } = state;
                const ecdhKeypair = yield generateECDHKeypair();
                socket.send(yield createHelloReq(ecdhKeypair.publicKey, associationKeypair.privateKey));
                state = {
                    __type: 'hello_req_sent',
                    associationPublicKey: associationKeypair.publicKey,
                    ecdhPrivateKey: ecdhKeypair.privateKey,
                };
            });
            const handleClose = (evt) => {
                if (evt.wasClean) {
                    state = { __type: 'disconnected' };
                }
                else {
                    reject(new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SESSION_CLOSED, `The wallet session dropped unexpectedly (${evt.code}: ${evt.reason}).`, { closeEvent: evt }));
                }
                disposeSocket();
            };
            const handleError = (_evt) => __awaiter(this, void 0, void 0, function* () {
                disposeSocket();
                if (Date.now() - connectionStartTime >= WEBSOCKET_CONNECTION_CONFIG.timeoutMs) {
                    reject(new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SESSION_TIMEOUT, `Failed to connect to the wallet websocket at ${websocketURL}.`));
                }
                else {
                    yield new Promise((resolve) => {
                        const retryDelayMs = getNextRetryDelayMs();
                        retryWaitTimeoutId = window.setTimeout(resolve, retryDelayMs);
                    });
                    attemptSocketConnection();
                }
            });
            const handleMessage = (evt) => __awaiter(this, void 0, void 0, function* () {
                const responseBuffer = yield evt.data.arrayBuffer();
                switch (state.__type) {
                    case 'connecting':
                        if (responseBuffer.byteLength !== 0) {
                            throw new Error('Encountered unexpected message while connecting');
                        }
                        const ecdhKeypair = yield generateECDHKeypair();
                        socket.send(yield createHelloReq(ecdhKeypair.publicKey, associationKeypair.privateKey));
                        state = {
                            __type: 'hello_req_sent',
                            associationPublicKey: associationKeypair.publicKey,
                            ecdhPrivateKey: ecdhKeypair.privateKey,
                        };
                        break;
                    case 'connected':
                        try {
                            const sequenceNumberVector = responseBuffer.slice(0, SEQUENCE_NUMBER_BYTES);
                            const sequenceNumber = getSequenceNumberFromByteArray(sequenceNumberVector);
                            if (sequenceNumber !== (lastKnownInboundSequenceNumber + 1)) {
                                throw new Error('Encrypted message has invalid sequence number');
                            }
                            lastKnownInboundSequenceNumber = sequenceNumber;
                            const jsonRpcMessage = yield decryptJsonRpcMessage(responseBuffer, state.sharedSecret);
                            const responsePromise = jsonRpcResponsePromises[jsonRpcMessage.id];
                            delete jsonRpcResponsePromises[jsonRpcMessage.id];
                            responsePromise.resolve(jsonRpcMessage.result);
                        }
                        catch (e) {
                            if (e instanceof SolanaMobileWalletAdapterProtocolError) {
                                const responsePromise = jsonRpcResponsePromises[e.jsonRpcMessageId];
                                delete jsonRpcResponsePromises[e.jsonRpcMessageId];
                                responsePromise.reject(e);
                            }
                            else {
                                throw e;
                            }
                        }
                        break;
                    case 'hello_req_sent': {
                        // if we receive an APP_PING message (empty message), resend the HELLO_REQ (see above)
                        if (responseBuffer.byteLength === 0) {
                            const ecdhKeypair = yield generateECDHKeypair();
                            socket.send(yield createHelloReq(ecdhKeypair.publicKey, associationKeypair.privateKey));
                            state = {
                                __type: 'hello_req_sent',
                                associationPublicKey: associationKeypair.publicKey,
                                ecdhPrivateKey: ecdhKeypair.privateKey,
                            };
                            break;
                        }
                        const sharedSecret = yield parseHelloRsp(responseBuffer, state.associationPublicKey, state.ecdhPrivateKey);
                        const sessionPropertiesBuffer = responseBuffer.slice(ENCODED_PUBLIC_KEY_LENGTH_BYTES);
                        const sessionProperties = sessionPropertiesBuffer.byteLength !== 0
                            ? yield (() => __awaiter(this, void 0, void 0, function* () {
                                const sequenceNumberVector = sessionPropertiesBuffer.slice(0, SEQUENCE_NUMBER_BYTES);
                                const sequenceNumber = getSequenceNumberFromByteArray(sequenceNumberVector);
                                if (sequenceNumber !== (lastKnownInboundSequenceNumber + 1)) {
                                    throw new Error('Encrypted message has invalid sequence number');
                                }
                                lastKnownInboundSequenceNumber = sequenceNumber;
                                return parseSessionProps(sessionPropertiesBuffer, sharedSecret);
                            }))() : { protocol_version: 'legacy' };
                        state = { __type: 'connected', sharedSecret, sessionProperties };
                        const wallet = createMobileWalletProxy(sessionProperties.protocol_version, (method, params) => __awaiter(this, void 0, void 0, function* () {
                            const id = nextJsonRpcMessageId++;
                            socket.send(yield encryptJsonRpcMessage({
                                id,
                                jsonrpc: '2.0',
                                method,
                                params: params !== null && params !== void 0 ? params : {},
                            }, sharedSecret));
                            return new Promise((resolve, reject) => {
                                jsonRpcResponsePromises[id] = {
                                    resolve(result) {
                                        switch (method) {
                                            case 'authorize':
                                            case 'reauthorize': {
                                                const { wallet_uri_base } = result;
                                                if (wallet_uri_base != null) {
                                                    try {
                                                        assertSecureEndpointSpecificURI(wallet_uri_base);
                                                    }
                                                    catch (e) {
                                                        reject(e);
                                                        return;
                                                    }
                                                }
                                                break;
                                            }
                                        }
                                        resolve(result);
                                    },
                                    reject,
                                };
                            });
                        }));
                        try {
                            resolve(yield callback(wallet));
                        }
                        catch (e) {
                            reject(e);
                        }
                        finally {
                            disposeSocket();
                            socket.close();
                        }
                        break;
                    }
                }
            });
            let disposeSocket;
            let retryWaitTimeoutId;
            const attemptSocketConnection = () => {
                if (disposeSocket) {
                    disposeSocket();
                }
                state = { __type: 'connecting', associationKeypair };
                if (connectionStartTime === undefined) {
                    connectionStartTime = Date.now();
                }
                socket = new WebSocket(websocketURL, [WEBSOCKET_PROTOCOL]);
                socket.addEventListener('open', handleOpen);
                socket.addEventListener('close', handleClose);
                socket.addEventListener('error', handleError);
                socket.addEventListener('message', handleMessage);
                disposeSocket = () => {
                    window.clearTimeout(retryWaitTimeoutId);
                    socket.removeEventListener('open', handleOpen);
                    socket.removeEventListener('close', handleClose);
                    socket.removeEventListener('error', handleError);
                    socket.removeEventListener('message', handleMessage);
                };
            };
            attemptSocketConnection();
        });
    });
}
function transactRemote(callback, config) {
    return __awaiter(this, void 0, void 0, function* () {
        assertSecureContext();
        const associationKeypair = yield generateAssociationKeypair();
        const { associationUrl, reflectorId } = yield getRemoteSessionUrl(associationKeypair.publicKey, config.remoteHostAuthority, config === null || config === void 0 ? void 0 : config.baseUri);
        const websocketURL = `wss://${config === null || config === void 0 ? void 0 : config.remoteHostAuthority}/reflect?id=${reflectorId}`;
        let connectionStartTime;
        const getNextRetryDelayMs = (() => {
            const schedule = [...WEBSOCKET_CONNECTION_CONFIG.retryDelayScheduleMs];
            return () => (schedule.length > 1 ? schedule.shift() : schedule[0]);
        })();
        let nextJsonRpcMessageId = 1;
        let lastKnownInboundSequenceNumber = 0;
        let state = { __type: 'disconnected' };
        return { associationUrl, result: new Promise((resolve, reject) => {
                let socket;
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const jsonRpcResponsePromises = {};
                const handleOpen = () => __awaiter(this, void 0, void 0, function* () {
                    if (state.__type !== 'connecting') {
                        console.warn('Expected adapter state to be `connecting` at the moment the websocket opens. ' +
                            `Got \`${state.__type}\`.`);
                        return;
                    }
                    socket.removeEventListener('open', handleOpen);
                });
                const handleClose = (evt) => {
                    if (evt.wasClean) {
                        state = { __type: 'disconnected' };
                    }
                    else {
                        reject(new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SESSION_CLOSED, `The wallet session dropped unexpectedly (${evt.code}: ${evt.reason}).`, { closeEvent: evt }));
                    }
                    disposeSocket();
                };
                const handleError = (_evt) => __awaiter(this, void 0, void 0, function* () {
                    disposeSocket();
                    if (Date.now() - connectionStartTime >= WEBSOCKET_CONNECTION_CONFIG.timeoutMs) {
                        reject(new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SESSION_TIMEOUT, `Failed to connect to the wallet websocket at ${websocketURL}.`));
                    }
                    else {
                        yield new Promise((resolve) => {
                            const retryDelayMs = getNextRetryDelayMs();
                            retryWaitTimeoutId = window.setTimeout(resolve, retryDelayMs);
                        });
                        attemptSocketConnection();
                    }
                });
                const handleMessage = (evt) => __awaiter(this, void 0, void 0, function* () {
                    const responseBuffer = yield evt.data.arrayBuffer();
                    switch (state.__type) {
                        case 'connecting':
                            if (responseBuffer.byteLength !== 0) {
                                throw new Error('Encountered unexpected message while connecting');
                            }
                            const ecdhKeypair = yield generateECDHKeypair();
                            socket.send(yield createHelloReq(ecdhKeypair.publicKey, associationKeypair.privateKey));
                            state = {
                                __type: 'hello_req_sent',
                                associationPublicKey: associationKeypair.publicKey,
                                ecdhPrivateKey: ecdhKeypair.privateKey,
                            };
                            break;
                        case 'connected':
                            try {
                                const sequenceNumberVector = responseBuffer.slice(0, SEQUENCE_NUMBER_BYTES);
                                const sequenceNumber = getSequenceNumberFromByteArray(sequenceNumberVector);
                                if (sequenceNumber !== (lastKnownInboundSequenceNumber + 1)) {
                                    throw new Error('Encrypted message has invalid sequence number');
                                }
                                lastKnownInboundSequenceNumber = sequenceNumber;
                                const jsonRpcMessage = yield decryptJsonRpcMessage(responseBuffer, state.sharedSecret);
                                const responsePromise = jsonRpcResponsePromises[jsonRpcMessage.id];
                                delete jsonRpcResponsePromises[jsonRpcMessage.id];
                                responsePromise.resolve(jsonRpcMessage.result);
                            }
                            catch (e) {
                                if (e instanceof SolanaMobileWalletAdapterProtocolError) {
                                    const responsePromise = jsonRpcResponsePromises[e.jsonRpcMessageId];
                                    delete jsonRpcResponsePromises[e.jsonRpcMessageId];
                                    responsePromise.reject(e);
                                }
                                else {
                                    throw e;
                                }
                            }
                            break;
                        case 'hello_req_sent': {
                            const sharedSecret = yield parseHelloRsp(responseBuffer, state.associationPublicKey, state.ecdhPrivateKey);
                            const sessionPropertiesBuffer = responseBuffer.slice(ENCODED_PUBLIC_KEY_LENGTH_BYTES);
                            const sessionProperties = sessionPropertiesBuffer.byteLength !== 0
                                ? yield (() => __awaiter(this, void 0, void 0, function* () {
                                    const sequenceNumberVector = sessionPropertiesBuffer.slice(0, SEQUENCE_NUMBER_BYTES);
                                    const sequenceNumber = getSequenceNumberFromByteArray(sequenceNumberVector);
                                    if (sequenceNumber !== (lastKnownInboundSequenceNumber + 1)) {
                                        throw new Error('Encrypted message has invalid sequence number');
                                    }
                                    lastKnownInboundSequenceNumber = sequenceNumber;
                                    return parseSessionProps(sessionPropertiesBuffer, sharedSecret);
                                }))() : { protocol_version: 'legacy' };
                            state = { __type: 'connected', sharedSecret, sessionProperties };
                            const wallet = createMobileWalletProxy(sessionProperties.protocol_version, (method, params) => __awaiter(this, void 0, void 0, function* () {
                                const id = nextJsonRpcMessageId++;
                                socket.send(yield encryptJsonRpcMessage({
                                    id,
                                    jsonrpc: '2.0',
                                    method,
                                    params: params !== null && params !== void 0 ? params : {},
                                }, sharedSecret));
                                return new Promise((resolve, reject) => {
                                    jsonRpcResponsePromises[id] = {
                                        resolve(result) {
                                            switch (method) {
                                                case 'authorize':
                                                case 'reauthorize': {
                                                    const { wallet_uri_base } = result;
                                                    if (wallet_uri_base != null) {
                                                        try {
                                                            assertSecureEndpointSpecificURI(wallet_uri_base);
                                                        }
                                                        catch (e) {
                                                            reject(e);
                                                            return;
                                                        }
                                                    }
                                                    break;
                                                }
                                            }
                                            resolve(result);
                                        },
                                        reject,
                                    };
                                });
                            }));
                            try {
                                resolve(yield callback(new Proxy(wallet, {
                                    get(target, p) {
                                        if (p === 'terminateSession') {
                                            disposeSocket();
                                            socket.close();
                                            return;
                                        }
                                        else
                                            return target[p];
                                    },
                                })));
                            }
                            catch (e) {
                                reject(e);
                            }
                            break;
                        }
                    }
                });
                let disposeSocket;
                let retryWaitTimeoutId;
                const attemptSocketConnection = () => {
                    if (disposeSocket) {
                        disposeSocket();
                    }
                    state = { __type: 'connecting', associationKeypair };
                    if (connectionStartTime === undefined) {
                        connectionStartTime = Date.now();
                    }
                    socket = new WebSocket(websocketURL, [WEBSOCKET_PROTOCOL]);
                    socket.addEventListener('open', handleOpen);
                    socket.addEventListener('close', handleClose);
                    socket.addEventListener('error', handleError);
                    socket.addEventListener('message', handleMessage);
                    disposeSocket = () => {
                        window.clearTimeout(retryWaitTimeoutId);
                        socket.removeEventListener('open', handleOpen);
                        socket.removeEventListener('close', handleClose);
                        socket.removeEventListener('error', handleError);
                        socket.removeEventListener('message', handleMessage);
                    };
                };
                attemptSocketConnection();
            }) };
    });
}

exports.SolanaCloneAuthorization = SolanaCloneAuthorization;
exports.SolanaMobileWalletAdapterError = SolanaMobileWalletAdapterError;
exports.SolanaMobileWalletAdapterErrorCode = SolanaMobileWalletAdapterErrorCode;
exports.SolanaMobileWalletAdapterProtocolError = SolanaMobileWalletAdapterProtocolError;
exports.SolanaMobileWalletAdapterProtocolErrorCode = SolanaMobileWalletAdapterProtocolErrorCode;
exports.SolanaSignInWithSolana = SolanaSignInWithSolana;
exports.SolanaSignTransactions = SolanaSignTransactions;
exports.transact = transact;
exports.transactRemote = transactRemote;
